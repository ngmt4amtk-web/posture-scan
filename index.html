<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>å§¿å‹¢ã‚¹ã‚­ãƒ£ãƒ³ â€” å§¿å‹¢è¨ˆæ¸¬ï¼†ãƒ‡ãƒ¼ã‚¿å‡ºåŠ›</title>
<style>
/* â”€â”€ CSS Variables â”€â”€ */
:root {
  --primary: #007AFF;
  --primary-dark: #0056CC;
  --bg: #F2F2F7;
  --card-bg: #FFFFFF;
  --text: #000000;
  --text-secondary: #3C3C43;
  --text-tertiary: #8E8E93;
  --separator: #C6C6C8;
  --green: #34C759;
  --orange: #FF9500;
  --red: #FF3B30;
  --cyan: #32ADE6;
  --overlay-skeleton: rgba(50, 173, 230, 0.7);
  --overlay-point: rgba(255, 255, 255, 0.9);
}

/* â”€â”€ Reset & Base â”€â”€ */
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
html, body {
  height: 100%; width: 100%;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
  background: var(--bg);
  color: var(--text);
  -webkit-font-smoothing: antialiased;
  -webkit-text-size-adjust: 100%;
  overflow: hidden;
}

/* â”€â”€ Screen System â”€â”€ */
.screen { display: none; flex-direction: column; height: 100%; width: 100%; position: absolute; top: 0; left: 0; }
.screen.active { display: flex; }

/* â”€â”€ Common Components â”€â”€ */
.card {
  background: var(--card-bg);
  border-radius: 12px;
  box-shadow: 0 1px 3px rgba(0,0,0,0.08);
  overflow: hidden;
}
.card-header {
  padding: 12px 16px;
  border-bottom: 1px solid #f0f0f0;
  display: flex;
  align-items: center;
  gap: 8px;
  font-weight: 600;
  font-size: 17px;
}
.card-body { padding: 16px; }

.btn {
  display: flex; align-items: center; justify-content: center; gap: 8px;
  width: 100%; padding: 16px; border: none; border-radius: 12px;
  font-size: 17px; font-weight: 600; cursor: pointer;
  transition: transform 0.1s, opacity 0.1s;
  -webkit-tap-highlight-color: transparent;
}
.btn:active { transform: scale(0.98); opacity: 0.9; }
.btn-primary { background: var(--primary); color: #fff; }
.btn-primary:disabled { background: #B0B0B0; cursor: not-allowed; }
.btn-secondary { background: #E5E5EA; color: var(--text); }
.btn-outline { background: transparent; color: var(--primary); border: 1.5px solid var(--primary); }

.badge {
  font-size: 11px; font-weight: 600;
  padding: 2px 8px; border-radius: 99px;
}
.badge-blue { background: #E8F0FE; color: var(--primary); }

/* â”€â”€ Screen 1: Mode Selection â”€â”€ */
#screenMode {
  padding: 0 20px;
  justify-content: center;
  gap: 16px;
}
#screenMode .title-area {
  text-align: center;
  padding: 40px 0 20px;
}
#screenMode h1 { font-size: 28px; font-weight: 700; letter-spacing: -0.5px; }
#screenMode .subtitle { color: var(--text-tertiary); font-size: 15px; margin-top: 8px; line-height: 1.5; }

.mode-card {
  background: var(--card-bg);
  border-radius: 16px;
  padding: 24px;
  display: flex; align-items: center; gap: 20px;
  cursor: pointer;
  border: 2px solid transparent;
  transition: border-color 0.2s, box-shadow 0.2s;
  box-shadow: 0 2px 8px rgba(0,0,0,0.06);
  -webkit-tap-highlight-color: transparent;
}
.mode-card:active { border-color: var(--primary); box-shadow: 0 2px 12px rgba(0,122,255,0.15); }
.mode-card .icon-area {
  width: 64px; height: 64px; flex-shrink: 0;
  display: flex; align-items: center; justify-content: center;
}
.mode-card .icon-area svg { width: 56px; height: 56px; }
.mode-card .info h3 { font-size: 18px; font-weight: 600; margin-bottom: 4px; }
.mode-card .info p { font-size: 13px; color: var(--text-tertiary); line-height: 1.4; }
.mode-card .info .mode-badge {
  display: inline-block; margin-top: 8px;
  font-size: 12px; font-weight: 500; padding: 3px 10px;
  border-radius: 99px;
}
.mode-card .info .mode-badge.simple { background: #E8F5E9; color: #2E7D32; }
.mode-card .info .mode-badge.thorough { background: #E3F2FD; color: #1565C0; }

/* â”€â”€ Screen 2: Settings â”€â”€ */
#screenSettings {
  padding: 0;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}
.settings-header {
  padding: 56px 24px 16px;
}
.settings-header h1 { font-size: 28px; font-weight: 700; }
.settings-header p { color: var(--text-tertiary); font-size: 15px; margin-top: 6px; }

.settings-content { padding: 0 16px 120px; display: flex; flex-direction: column; gap: 16px; }

/* Wheel Picker */
.wheel-picker-container {
  position: relative;
  height: 200px;
  overflow: hidden;
  -webkit-mask-image: linear-gradient(to bottom,
    transparent 0%, rgba(0,0,0,0.3) 15%, black 35%, black 65%, rgba(0,0,0,0.3) 85%, transparent 100%);
  mask-image: linear-gradient(to bottom,
    transparent 0%, rgba(0,0,0,0.3) 15%, black 35%, black 65%, rgba(0,0,0,0.3) 85%, transparent 100%);
}
.wheel-picker-highlight {
  position: absolute;
  top: 50%; left: 0; right: 0;
  height: 40px; transform: translateY(-50%);
  background: rgba(0,122,255,0.06);
  border-top: 1px solid var(--separator);
  border-bottom: 1px solid var(--separator);
  pointer-events: none;
  z-index: 1;
}
.wheel-picker-list {
  position: absolute;
  top: 0; left: 0; right: 0;
  will-change: transform;
  transition: transform 0.1s ease-out;
}
.wheel-picker-item {
  height: 40px;
  display: flex; align-items: center; justify-content: center;
  font-size: 20px; font-weight: 400;
  color: var(--text);
  user-select: none;
  -webkit-user-select: none;
}
.wheel-picker-item.selected { font-weight: 600; color: var(--primary); }
.wheel-picker-unit {
  text-align: center;
  font-size: 14px;
  color: var(--text-tertiary);
  margin-top: 8px;
}

/* Segment Control */
.segment-control {
  display: flex;
  background: var(--bg);
  border-radius: 8px;
  padding: 2px;
  position: relative;
}
.segment-control .slider {
  position: absolute;
  top: 2px; bottom: 2px;
  width: calc(50% - 2px);
  background: var(--card-bg);
  border-radius: 7px;
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  transition: left 0.25s ease;
  left: 2px;
}
.segment-control.right .slider { left: calc(50%); }
.segment-control button {
  flex: 1;
  padding: 10px;
  border: none;
  background: none;
  font-size: 14px;
  font-weight: 600;
  color: var(--text-secondary);
  opacity: 0.6;
  cursor: pointer;
  position: relative;
  z-index: 1;
  transition: opacity 0.2s;
  -webkit-tap-highlight-color: transparent;
}
.segment-control button.active { opacity: 1; color: var(--text); }

.side-description {
  margin-top: 12px;
  padding: 12px;
  background: #F8F8FA;
  border-radius: 8px;
  display: flex; align-items: flex-start; gap: 10px;
}
.side-description .info-icon { color: var(--text-tertiary); font-size: 18px; flex-shrink: 0; margin-top: 1px; }
.side-description p { font-size: 13px; color: var(--text-secondary); line-height: 1.5; }

.settings-bottom {
  position: fixed; bottom: 0; left: 0; right: 0;
  padding: 16px 20px 32px;
  background: linear-gradient(transparent, var(--bg) 20%);
  z-index: 10;
}

/* â”€â”€ Screen 3: Measurement â”€â”€ */
#screenMeasure {
  background: #000;
  position: relative;
}
.camera-container {
  flex: 1; position: relative; overflow: hidden;
}
.camera-container video {
  width: 100%; height: 100%;
  object-fit: cover;
}
.camera-container video.mirror { transform: scaleX(-1); }
.camera-container canvas {
  position: absolute; top: 0; left: 0;
  width: 100%; height: 100%;
  pointer-events: none;
}
.camera-container canvas.mirror { transform: scaleX(-1); }

.measure-overlay {
  position: absolute; top: 0; left: 0; right: 0; bottom: 0;
  display: flex; flex-direction: column;
  align-items: center; justify-content: center;
  pointer-events: none;
  z-index: 10;
}

.countdown-number {
  font-size: 120px;
  font-weight: 800;
  color: rgba(255,255,255,0.9);
  text-shadow: 0 4px 20px rgba(0,0,0,0.5);
  line-height: 1;
  opacity: 0;
  transition: opacity 0.15s;
}
.countdown-number.visible { opacity: 1; }

.countdown-label {
  font-size: 16px;
  font-weight: 500;
  color: rgba(255,255,255,0.7);
  margin-top: 12px;
}

.measure-progress {
  position: absolute; bottom: 0; left: 0; right: 0;
  height: 4px; background: rgba(255,255,255,0.2);
}
.measure-progress-bar {
  height: 100%; background: var(--primary);
  width: 0; transition: width 0.1s linear;
}

.measure-status {
  position: absolute; top: 0; left: 0; right: 0;
  padding: 52px 16px 12px;
  background: linear-gradient(rgba(0,0,0,0.5), transparent);
  display: flex; align-items: center; justify-content: space-between;
  z-index: 11;
}
.measure-status .status-left { display: flex; align-items: center; gap: 8px; }
.measure-status .status-badge {
  font-size: 12px; font-weight: 600; color: #fff;
  padding: 4px 10px; border-radius: 99px;
}
.measure-status .status-badge.loading { background: var(--orange); }
.measure-status .status-badge.ready { background: var(--green); }
.measure-status .status-badge.recording { background: var(--red); animation: pulse 1s infinite; }
.measure-status .fps-badge {
  font-size: 11px; color: rgba(255,255,255,0.7);
  padding: 2px 6px; background: rgba(0,0,0,0.4); border-radius: 4px;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.6; }
}

.landmark-count {
  font-size: 13px; color: rgba(255,255,255,0.8);
}

.measure-bottom-controls {
  position: absolute; bottom: 24px; left: 0; right: 0;
  display: flex; justify-content: center; gap: 16px;
  z-index: 11;
  pointer-events: auto;
}
.measure-bottom-controls .btn {
  width: auto; padding: 12px 32px;
  border-radius: 99px;
  box-shadow: 0 4px 16px rgba(0,0,0,0.3);
}

/* Side switch screen */
.side-switch-overlay {
  position: absolute; top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.85);
  display: none; flex-direction: column;
  align-items: center; justify-content: center;
  z-index: 20; gap: 24px; padding: 40px;
}
.side-switch-overlay.visible { display: flex; }
.side-switch-overlay h2 { color: #fff; font-size: 24px; text-align: center; }
.side-switch-overlay p { color: rgba(255,255,255,0.7); font-size: 15px; text-align: center; line-height: 1.6; }
.side-switch-overlay .btn { width: auto; padding: 14px 40px; }

/* Camera toggle */
.camera-toggle-btn {
  position: absolute; top: 52px; right: 16px;
  width: 40px; height: 40px;
  background: rgba(0,0,0,0.4); border: none; border-radius: 50%;
  color: #fff; font-size: 20px; cursor: pointer;
  display: flex; align-items: center; justify-content: center;
  z-index: 11;
  -webkit-tap-highlight-color: transparent;
}

/* â”€â”€ Screen 4: Export â”€â”€ */
#screenExport {
  padding: 0 20px;
  justify-content: center;
  gap: 20px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}
.export-header {
  text-align: center;
  padding: 56px 0 12px;
}
.export-header .check-icon {
  width: 64px; height: 64px;
  background: var(--green);
  border-radius: 50%;
  display: flex; align-items: center; justify-content: center;
  margin: 0 auto 16px;
}
.export-header .check-icon svg { width: 32px; height: 32px; fill: #fff; }
.export-header h1 { font-size: 24px; font-weight: 700; }
.export-header p { font-size: 14px; color: var(--text-tertiary); margin-top: 6px; }

.export-stats {
  display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px;
  padding: 0 4px;
}
.export-stat {
  background: var(--card-bg);
  border-radius: 10px;
  padding: 12px 8px;
  text-align: center;
}
.export-stat .value { font-size: 20px; font-weight: 700; color: var(--primary); }
.export-stat .label { font-size: 11px; color: var(--text-tertiary); margin-top: 2px; }

.export-buttons { display: flex; flex-direction: column; gap: 12px; padding: 0 4px; }

.export-btn-info { font-size: 12px; color: var(--text-tertiary); text-align: center; margin-top: -4px; }

/* â”€â”€ Loading Screen â”€â”€ */
#screenLoading {
  background: var(--bg);
  align-items: center; justify-content: center; gap: 16px;
}
#screenLoading .spinner {
  width: 40px; height: 40px;
  border: 3px solid var(--separator);
  border-top-color: var(--primary);
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
}
@keyframes spin { to { transform: rotate(360deg); } }
#screenLoading .loading-text { font-size: 15px; color: var(--text-secondary); text-align: center; }

/* â”€â”€ Utility â”€â”€ */
.hidden { display: none !important; }
</style>
</head>
<body>

<!-- ============ Screen: Loading ============ -->
<div class="screen active" id="screenLoading">
  <div class="spinner"></div>
  <div class="loading-text" id="loadingText">MediaPipe ã‚’èª­ã¿è¾¼ã¿ä¸­...</div>
</div>

<!-- ============ Screen 1: Mode Selection ============ -->
<div class="screen" id="screenMode">
  <div class="title-area">
    <h1>å§¿å‹¢ã‚¹ã‚­ãƒ£ãƒ³</h1>
    <p class="subtitle">ã‚«ãƒ¡ãƒ©ã§å§¿å‹¢ã‚’è¨ˆæ¸¬ã—ã¦<br>ãƒ‡ãƒ¼ã‚¿ã‚’txtã§å‡ºåŠ›ã—ã¾ã™</p>
  </div>

  <div class="mode-card" id="btnSimple">
    <div class="icon-area">
      <svg viewBox="0 0 64 64" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" color="#007AFF">
        <circle cx="32" cy="14" r="6"/>
        <line x1="32" y1="20" x2="32" y2="42"/>
        <line x1="20" y1="30" x2="44" y2="30"/>
        <line x1="32" y1="42" x2="22" y2="58"/>
        <line x1="32" y1="42" x2="42" y2="58"/>
      </svg>
    </div>
    <div class="info">
      <h3>ç°¡æ˜“</h3>
      <p>æ­£é¢ã®ã¿ãƒ»15ç§’<br>ã‚µã‚¯ãƒƒã¨ãƒã‚§ãƒƒã‚¯ã—ãŸã„ã¨ã</p>
      <span class="mode-badge simple">Quick</span>
    </div>
  </div>

  <div class="mode-card" id="btnThorough">
    <div class="icon-area">
      <svg viewBox="0 0 80 64" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" color="#007AFF">
        <circle cx="24" cy="14" r="6"/>
        <line x1="24" y1="20" x2="24" y2="42"/>
        <line x1="12" y1="30" x2="36" y2="30"/>
        <line x1="24" y1="42" x2="14" y2="58"/>
        <line x1="24" y1="42" x2="34" y2="58"/>
        <circle cx="58" cy="14" r="6"/>
        <line x1="58" y1="20" x2="58" y2="42"/>
        <line x1="52" y1="28" x2="64" y2="32"/>
        <line x1="58" y1="42" x2="48" y2="58"/>
        <line x1="58" y1="42" x2="68" y2="58"/>
        <text x="41" y="40" font-size="16" fill="#007AFF" stroke="none" font-weight="600">+</text>
      </svg>
    </div>
    <div class="info">
      <h3>ã—ã£ã‹ã‚Š</h3>
      <p>æ­£é¢ï¼‹å´é¢ãƒ»30ç§’<br>è©³ã—ãåˆ†æã—ãŸã„ã¨ã</p>
      <span class="mode-badge thorough">Thorough</span>
    </div>
  </div>

  <p style="text-align:center; font-size:12px; color:var(--text-tertiary); padding: 8px 0 24px;">
    è¨ˆæ¸¬ãƒ‡ãƒ¼ã‚¿ã‚’AIã«æ¸¡ã—ã¦å§¿å‹¢ã®ç›¸è«‡ãŒã§ãã¾ã™
  </p>
</div>

<!-- ============ Screen 2: Settings ============ -->
<div class="screen" id="screenSettings">
  <div class="settings-header">
    <h1>è¨­å®š</h1>
    <p>è¨ˆæ¸¬ã®æº–å‚™ã‚’ã—ã¾ã™</p>
  </div>

  <div class="settings-content">
    <!-- Height Picker -->
    <div class="card">
      <div class="card-header">
        <span style="font-size:20px;">ğŸ“</span>
        <span>èº«é•·</span>
      </div>
      <div class="card-body">
        <div class="wheel-picker-container" id="heightPicker">
          <div class="wheel-picker-highlight"></div>
          <div class="wheel-picker-list" id="heightPickerList"></div>
        </div>
        <div class="wheel-picker-unit">cm</div>
      </div>
    </div>

    <!-- Side Selection (thorough only) -->
    <div class="card" id="sideSelectionCard" style="display:none;">
      <div class="card-header">
        <span style="font-size:20px;">ğŸ“</span>
        <span>å´é¢æ’®å½±ã®å‘ã</span>
        <span class="badge badge-blue" style="margin-left:auto;">ã—ã£ã‹ã‚Šãƒ¢ãƒ¼ãƒ‰</span>
      </div>
      <div class="card-body">
        <p style="font-size:14px; color:var(--text-secondary); margin-bottom:12px;">
          å´é¢æ’®å½±æ™‚ã«ã©ã¡ã‚‰å´ã‚’æ’®å½±ã—ã¾ã™ã‹ï¼Ÿ
        </p>
        <div class="segment-control" id="sideSegment">
          <div class="slider"></div>
          <button class="active" id="btnSideLeft">å·¦å´é¢</button>
          <button id="btnSideRight">å³å´é¢</button>
        </div>
        <div class="side-description" id="sideDescription">
          <span class="info-icon">â„¹ï¸</span>
          <p id="sideDescText">å·¦å´é¢ã‹ã‚‰æ’®å½±ã—ã¾ã™ã€‚å£ã‚„ãƒ‰ã‚¢ã®å‰ãªã©ã€èƒŒæ™¯ãŒã‚·ãƒ³ãƒ—ãƒ«ãªå ´æ‰€ãŒãŠã™ã™ã‚ã§ã™</p>
        </div>
      </div>
    </div>
  </div>

  <div class="settings-bottom">
    <button class="btn btn-primary" id="btnStartMeasure">è¨ˆæ¸¬é–‹å§‹</button>
  </div>
</div>

<!-- ============ Screen 3: Measurement ============ -->
<div class="screen" id="screenMeasure">
  <div class="camera-container">
    <video id="video" playsinline autoplay muted></video>
    <canvas id="overlay"></canvas>
  </div>

  <div class="measure-status">
    <div class="status-left">
      <span class="status-badge loading" id="statusBadge">æº–å‚™ä¸­</span>
      <span class="fps-badge" id="fpsBadge">-- FPS</span>
    </div>
    <span class="landmark-count" id="landmarkCount">--/17</span>
  </div>

  <button class="camera-toggle-btn" id="btnCameraToggle">ğŸ”„</button>

  <div class="measure-overlay" id="measureOverlay">
    <div class="countdown-number" id="countdownNumber"></div>
    <div class="countdown-label" id="countdownLabel"></div>
  </div>

  <div class="measure-progress" id="measureProgress" style="display:none;">
    <div class="measure-progress-bar" id="measureProgressBar"></div>
  </div>

  <div class="measure-bottom-controls" id="measureControls">
    <button class="btn btn-primary" id="btnBeginMeasure" disabled>è¨ˆæ¸¬é–‹å§‹</button>
  </div>

  <!-- Side switch overlay -->
  <div class="side-switch-overlay" id="sideSwitchOverlay">
    <h2>å´é¢æ’®å½±ã«åˆ‡ã‚Šæ›¿ãˆ</h2>
    <p id="sideSwitchText">ã‚«ãƒ¡ãƒ©ã‚’æ¨ªã«ç§»å‹•ã—ã¦ã€å·¦å´é¢ãŒæ˜ ã‚‹ã‚ˆã†ã«ã—ã¦ãã ã•ã„</p>
    <button class="btn btn-primary" id="btnSideReady">æº–å‚™ã§ããŸ</button>
  </div>
</div>

<!-- ============ Screen 4: Export ============ -->
<div class="screen" id="screenExport">
  <div class="export-header">
    <div class="check-icon">
      <svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/></svg>
    </div>
    <h1>è¨ˆæ¸¬å®Œäº†</h1>
    <p id="exportSummaryText">ç°¡æ˜“ãƒ¢ãƒ¼ãƒ‰ãƒ»15ç§’é–“</p>
  </div>

  <div class="export-stats" id="exportStats">
    <div class="export-stat">
      <div class="value" id="statFrames">0</div>
      <div class="label">ãƒ•ãƒ¬ãƒ¼ãƒ </div>
    </div>
    <div class="export-stat">
      <div class="value" id="statMetrics">0</div>
      <div class="label">æŒ‡æ¨™</div>
    </div>
    <div class="export-stat">
      <div class="value" id="statFps">0</div>
      <div class="label">å¹³å‡FPS</div>
    </div>
  </div>

  <div class="export-buttons">
    <button class="btn btn-primary" id="btnExportSimple">ğŸ“„ ç°¡æ˜“ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button>
    <p class="export-btn-info">ã‚µãƒãƒªãƒ¼ã®ã¿ â€” AIç›¸è«‡ãƒ»ç¸¦æ–­æ¯”è¼ƒã«</p>
    <button class="btn btn-outline" id="btnExportDetail">ğŸ“Š è©³ç´°ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button>
    <p class="export-btn-info">å…¨ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿ â€” è©³ç´°åˆ†æãƒ»ç ”ç©¶ã«</p>
    <button class="btn btn-secondary" id="btnRetry" style="margin-top:8px;">ã‚‚ã†ä¸€åº¦è¨ˆæ¸¬ã™ã‚‹</button>
  </div>
</div>

<script type="module">
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  å§¿å‹¢ã‚¹ã‚­ãƒ£ãƒ³ â€” Main Application Script
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import {
  PoseLandmarker,
  FilesetResolver,
} from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.18/vision_bundle.mjs";

// â”€â”€ Constants â”€â”€
const VISION_CDN = 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.18/wasm';
const MODEL_FULL = 'https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task';
const MODEL_LITE = 'https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/latest/pose_landmarker_lite.task';

const EMA_ALPHA = 0.3;
const MEASURE_DURATION = 15;
const COUNTDOWN_DURATION = 5;
const VISIBILITY_THRESHOLD = 0.3;

// Landmark indices (MediaPipe Pose 33-point model)
const LM = {
  NOSE: 0, L_EAR: 7, R_EAR: 8,
  L_SHOULDER: 11, R_SHOULDER: 12,
  L_ELBOW: 13, R_ELBOW: 14,
  L_WRIST: 15, R_WRIST: 16,
  L_HIP: 23, R_HIP: 24,
  L_KNEE: 25, R_KNEE: 26,
  L_ANKLE: 27, R_ANKLE: 28,
};
const TRACKED_INDICES = [0, 7, 8, 11, 12, 13, 14, 15, 16, 23, 24, 25, 26, 27, 28];
const TRACKED_NAMES = ['nose','l_ear','r_ear','l_shoulder','r_shoulder','l_elbow','r_elbow','l_wrist','r_wrist','l_hip','r_hip','l_knee','r_knee','l_ankle','r_ankle'];

// Skeleton connections
const SKELETON_CONNECTIONS = [
  [LM.L_EAR, LM.NOSE], [LM.R_EAR, LM.NOSE],
  [LM.L_SHOULDER, LM.R_SHOULDER],
  [LM.L_SHOULDER, LM.L_ELBOW], [LM.L_ELBOW, LM.L_WRIST],
  [LM.R_SHOULDER, LM.R_ELBOW], [LM.R_ELBOW, LM.R_WRIST],
  [LM.L_SHOULDER, LM.L_HIP], [LM.R_SHOULDER, LM.R_HIP],
  [LM.L_HIP, LM.R_HIP],
  [LM.L_HIP, LM.L_KNEE], [LM.L_KNEE, LM.L_ANKLE],
  [LM.R_HIP, LM.R_KNEE], [LM.R_KNEE, LM.R_ANKLE],
];

// Front metric keys
const FRONT_METRIC_KEYS = [
  'head_lateral_tilt','shoulder_asymmetry','trunk_lateral_shift',
  'pelvic_tilt','knee_valgus_angle'
];
// Side metric keys
const SIDE_METRIC_KEYS = [
  'cva','forward_shoulder_angle','thoracic_kyphosis',
  'pelvic_anterior_tilt','plumb_line_deviation'
];

// â”€â”€ State â”€â”€
let poseLandmarker = null;
let delegate = '';
let stream = null;
let facingMode = 'environment';
let isDetecting = false;
let lastVideoTime = -1;
let frameCount = 0;
let fpsTime = 0;
let currentFps = 0;

let appMode = 'simple';
let selectedSide = 'left';
let selectedHeight = 160;
let measurePhase = 'idle';
let countdownTimer = null;
let measureStartTime = 0;
let isSideMeasuring = false;

let emaLandmarks = null;
let frontFrames = [];
let sideFrames = [];
let confidenceAccum = {};

// â”€â”€ DOM References â”€â”€
const $ = id => document.getElementById(id);
const video = $('video');
const overlay = $('overlay');
const ctx = overlay.getContext('2d');

// â”€â”€ Utility Functions â”€â”€
function rad2deg(r) { return r * 180 / Math.PI; }

function distance(a, b) {
  const dx = a.x - b.x, dy = a.y - b.y;
  return Math.sqrt(dx * dx + dy * dy);
}

function angleBetween3(a, b, c) {
  const ba = { x: a.x - b.x, y: a.y - b.y };
  const bc = { x: c.x - b.x, y: c.y - b.y };
  const dot = ba.x * bc.x + ba.y * bc.y;
  const magBA = Math.sqrt(ba.x * ba.x + ba.y * ba.y);
  const magBC = Math.sqrt(bc.x * bc.x + bc.y * bc.y);
  if (magBA === 0 || magBC === 0) return null;
  return rad2deg(Math.acos(Math.max(-1, Math.min(1, dot / (magBA * magBC)))));
}

function ema(prev, curr) {
  if (prev === null || prev === undefined) return curr;
  return prev + EMA_ALPHA * (curr - prev);
}

function isVisible(lm, idx) {
  return lm[idx] && (lm[idx].visibility || 0) >= VISIBILITY_THRESHOLD;
}

function getLm(lm, idx) {
  return lm[idx] || { x: 0, y: 0, z: 0, visibility: 0 };
}

// â”€â”€ Angle Calculation: Front â”€â”€
function calcFrontMetrics(lm) {
  const m = {};
  const lEar = getLm(lm, LM.L_EAR), rEar = getLm(lm, LM.R_EAR);
  const lSh = getLm(lm, LM.L_SHOULDER), rSh = getLm(lm, LM.R_SHOULDER);
  const lHip = getLm(lm, LM.L_HIP), rHip = getLm(lm, LM.R_HIP);
  const lKnee = getLm(lm, LM.L_KNEE), rKnee = getLm(lm, LM.R_KNEE);
  const lAnkle = getLm(lm, LM.L_ANKLE), rAnkle = getLm(lm, LM.R_ANKLE);

  // F1: Head lateral tilt (ear-to-ear angle from horizontal)
  if (isVisible(lm, LM.L_EAR) && isVisible(lm, LM.R_EAR)) {
    const dy = lEar.y - rEar.y;
    const dx = rEar.x - lEar.x;
    m.head_lateral_tilt = rad2deg(Math.atan2(dy, dx));
  }

  // F2: Shoulder asymmetry (shoulder line angle from horizontal)
  if (isVisible(lm, LM.L_SHOULDER) && isVisible(lm, LM.R_SHOULDER)) {
    const dy = lSh.y - rSh.y;
    const dx = rSh.x - lSh.x;
    m.shoulder_asymmetry = rad2deg(Math.atan2(dy, dx));
  }

  // F3: Trunk lateral shift (mid-shoulder to mid-hip deviation from vertical)
  if (isVisible(lm, LM.L_SHOULDER) && isVisible(lm, LM.R_SHOULDER) &&
      isVisible(lm, LM.L_HIP) && isVisible(lm, LM.R_HIP)) {
    const shMidX = (lSh.x + rSh.x) / 2, shMidY = (lSh.y + rSh.y) / 2;
    const hipMidX = (lHip.x + rHip.x) / 2, hipMidY = (lHip.y + rHip.y) / 2;
    m.trunk_lateral_shift = rad2deg(Math.atan2(shMidX - hipMidX, hipMidY - shMidY));
  }

  // F4: Pelvic tilt (hip line angle from horizontal)
  if (isVisible(lm, LM.L_HIP) && isVisible(lm, LM.R_HIP)) {
    const dy = lHip.y - rHip.y;
    const dx = rHip.x - lHip.x;
    m.pelvic_tilt = rad2deg(Math.atan2(dy, dx));
  }

  // F5: Knee valgus angle (average of both knees: hip-knee-ankle angle deviation from 180)
  const kneeAngles = [];
  if (isVisible(lm, LM.L_HIP) && isVisible(lm, LM.L_KNEE) && isVisible(lm, LM.L_ANKLE)) {
    const a = angleBetween3(lHip, lKnee, lAnkle);
    if (a !== null) kneeAngles.push(180 - a);
  }
  if (isVisible(lm, LM.R_HIP) && isVisible(lm, LM.R_KNEE) && isVisible(lm, LM.R_ANKLE)) {
    const a = angleBetween3(rHip, rKnee, rAnkle);
    if (a !== null) kneeAngles.push(180 - a);
  }
  if (kneeAngles.length > 0) {
    m.knee_valgus_angle = kneeAngles.reduce((a, b) => a + b, 0) / kneeAngles.length;
  }

  return m;
}

// â”€â”€ Angle Calculation: Side â”€â”€
function calcSideMetrics(lm) {
  const m = {};
  const ear = isVisible(lm, LM.L_EAR) ? getLm(lm, LM.L_EAR) : getLm(lm, LM.R_EAR);
  const sh = isVisible(lm, LM.L_SHOULDER) ? getLm(lm, LM.L_SHOULDER) : getLm(lm, LM.R_SHOULDER);
  const hip = isVisible(lm, LM.L_HIP) ? getLm(lm, LM.L_HIP) : getLm(lm, LM.R_HIP);
  const knee = isVisible(lm, LM.L_KNEE) ? getLm(lm, LM.L_KNEE) : getLm(lm, LM.R_KNEE);
  const ankle = isVisible(lm, LM.L_ANKLE) ? getLm(lm, LM.L_ANKLE) : getLm(lm, LM.R_ANKLE);

  const earVis = isVisible(lm, LM.L_EAR) || isVisible(lm, LM.R_EAR);
  const shVis = isVisible(lm, LM.L_SHOULDER) || isVisible(lm, LM.R_SHOULDER);
  const hipVis = isVisible(lm, LM.L_HIP) || isVisible(lm, LM.R_HIP);
  const kneeVis = isVisible(lm, LM.L_KNEE) || isVisible(lm, LM.R_KNEE);
  const ankleVis = isVisible(lm, LM.L_ANKLE) || isVisible(lm, LM.R_ANKLE);

  // S1: CVA (Craniovertebral Angle) â€” ear-to-shoulder angle from horizontal
  // Higher = more upright. Normal >53Â°, <45Â° severe FHP
  if (earVis && shVis) {
    const dx = Math.abs(ear.x - sh.x);
    const dy = sh.y - ear.y; // shoulder is below ear
    m.cva = rad2deg(Math.atan2(dy, dx));
  }

  // S2: Forward Shoulder Angle â€” shoulder offset from hip in sagittal plane
  if (shVis && hipVis) {
    const dx = sh.x - hip.x;
    const dy = hip.y - sh.y;
    m.forward_shoulder_angle = rad2deg(Math.atan2(Math.abs(dx), dy));
  }

  // S3: Thoracic kyphosis estimate â€” shoulder-to-hip angle in sagittal plane
  if (shVis && hipVis && earVis) {
    // Use ear-shoulder-hip angle as proxy
    const a = angleBetween3(ear, sh, hip);
    if (a !== null) m.thoracic_kyphosis = 180 - a;
  }

  // S4: Pelvic anterior tilt â€” hip-knee angle from vertical
  if (hipVis && kneeVis) {
    const dx = hip.x - knee.x;
    const dy = knee.y - hip.y;
    m.pelvic_anterior_tilt = rad2deg(Math.atan2(Math.abs(dx), dy));
  }

  // S5: Plumb line deviation â€” how far key points deviate from ideal vertical
  // Ideal: ear, shoulder, hip, knee, ankle all on same vertical line
  if (earVis && shVis && hipVis && ankleVis) {
    const refX = ankle.x; // ankle as reference vertical
    const deviations = [
      Math.abs(ear.x - refX),
      Math.abs(sh.x - refX),
      Math.abs(hip.x - refX),
    ];
    if (kneeVis) deviations.push(Math.abs(knee.x - refX));
    const avgDev = deviations.reduce((a, b) => a + b, 0) / deviations.length;
    // Normalize by body height (ear-to-ankle distance)
    const bodyH = Math.abs(ear.y - ankle.y);
    m.plumb_line_deviation = bodyH > 0.01 ? (avgDev / bodyH) * 100 : 0;
  }

  return m;
}

// â”€â”€ EMA Smoothing â”€â”€
function smoothLandmarks(rawLm) {
  if (!emaLandmarks) {
    emaLandmarks = rawLm.map(p => ({ x: p.x, y: p.y, z: p.z, visibility: p.visibility }));
    return emaLandmarks;
  }
  emaLandmarks = rawLm.map((p, i) => ({
    x: ema(emaLandmarks[i]?.x, p.x),
    y: ema(emaLandmarks[i]?.y, p.y),
    z: ema(emaLandmarks[i]?.z, p.z),
    visibility: p.visibility,
  }));
  return emaLandmarks;
}

// â”€â”€ Statistics â”€â”€
function calcStats(values) {
  const filtered = values.filter(v => v !== null && v !== undefined);
  if (filtered.length === 0) return null;
  const n = filtered.length;
  const avg = filtered.reduce((a, b) => a + b, 0) / n;
  const sd = Math.sqrt(filtered.reduce((s, v) => s + (v - avg) ** 2, 0) / n);
  const min = Math.min(...filtered);
  const max = Math.max(...filtered);
  return { avg: +avg.toFixed(1), sd: +sd.toFixed(1), min: +min.toFixed(1), max: +max.toFixed(1) };
}

// â”€â”€ Drawing â”€â”€
function drawSkeleton(lm) {
  const w = overlay.width, h = overlay.height;
  ctx.clearRect(0, 0, w, h);
  if (!lm || lm.length === 0) return;

  // Draw plumb line during side measurement
  if (isSideMeasuring) {
    const ankle = isVisible(lm, LM.L_ANKLE) ? getLm(lm, LM.L_ANKLE) :
                  isVisible(lm, LM.R_ANKLE) ? getLm(lm, LM.R_ANKLE) : null;
    if (ankle) {
      ctx.save();
      ctx.setLineDash([8, 6]);
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(255, 215, 0, 0.6)';
      ctx.beginPath();
      ctx.moveTo(ankle.x * w, 0);
      ctx.lineTo(ankle.x * w, h);
      ctx.stroke();
      ctx.restore();

      // Label
      ctx.font = '12px -apple-system, sans-serif';
      ctx.fillStyle = 'rgba(255, 215, 0, 0.8)';
      ctx.fillText('ç†æƒ³ãƒ©ã‚¤ãƒ³', ankle.x * w + 6, 20);
    }
  }

  // Connections
  ctx.lineWidth = 2.5;
  ctx.strokeStyle = 'rgba(50, 173, 230, 0.7)';
  for (const [si, ei] of SKELETON_CONNECTIONS) {
    const s = lm[si], e = lm[ei];
    if (!s || !e || (s.visibility || 0) < VISIBILITY_THRESHOLD || (e.visibility || 0) < VISIBILITY_THRESHOLD) continue;
    ctx.beginPath();
    ctx.moveTo(s.x * w, s.y * h);
    ctx.lineTo(e.x * w, e.y * h);
    ctx.stroke();
  }

  // Points
  for (const idx of TRACKED_INDICES) {
    const p = lm[idx];
    if (!p || (p.visibility || 0) < VISIBILITY_THRESHOLD) continue;
    ctx.beginPath();
    ctx.arc(p.x * w, p.y * h, 4, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.fill();
    ctx.strokeStyle = 'rgba(0,0,0,0.3)';
    ctx.lineWidth = 1;
    ctx.stroke();
  }
}

// â”€â”€ Frame Processing â”€â”€
function processFrame(rawLm, timestamp) {
  const lm = smoothLandmarks(rawLm);

  let visCount = 0;
  for (const idx of TRACKED_INDICES) {
    if (isVisible(lm, idx)) visCount++;
  }
  $('landmarkCount').textContent = `${visCount}/${TRACKED_INDICES.length}`;

  if (measurePhase === 'position' || measurePhase === 'side-position') {
    $('btnBeginMeasure').disabled = visCount < 5;
  }

  // Accumulate confidence
  for (let i = 0; i < TRACKED_INDICES.length; i++) {
    const idx = TRACKED_INDICES[i];
    const name = TRACKED_NAMES[i];
    if (!confidenceAccum[name]) confidenceAccum[name] = { vis: [] };
    confidenceAccum[name].vis.push(lm[idx]?.visibility || 0);
  }

  // Record frame during measurement
  if (measurePhase === 'measuring' || measurePhase === 'side-measuring') {
    const isSide = measurePhase === 'side-measuring';
    const metrics = isSide ? calcSideMetrics(lm) : calcFrontMetrics(lm);

    const frameData = {
      timestamp,
      landmarks: TRACKED_INDICES.map(idx => ({
        x: +(lm[idx].x).toFixed(5),
        y: +(lm[idx].y).toFixed(5),
        z: +(lm[idx].z).toFixed(5),
        visibility: +(lm[idx].visibility || 0).toFixed(3),
      })),
      metrics,
    };

    if (isSide) {
      sideFrames.push(frameData);
    } else {
      frontFrames.push(frameData);
    }
  }

  drawSkeleton(lm);
}

// â”€â”€ Detection Loop â”€â”€
function detectLoop() {
  if (!isDetecting) return;
  requestAnimationFrame(detectLoop);
  if (!poseLandmarker || video.readyState < 2) return;

  const t = video.currentTime;
  if (t === lastVideoTime) return;
  lastVideoTime = t;

  const ts = performance.now();
  let result;
  try {
    result = poseLandmarker.detectForVideo(video, ts);
  } catch (e) {
    return;
  }

  frameCount++;
  if (ts - fpsTime >= 1000) {
    currentFps = frameCount;
    frameCount = 0;
    fpsTime = ts;
    $('fpsBadge').textContent = currentFps + ' FPS';
  }

  if (result.landmarks && result.landmarks.length > 0) {
    processFrame(result.landmarks[0], ts);
  } else {
    ctx.clearRect(0, 0, overlay.width, overlay.height);
    $('landmarkCount').textContent = `0/${TRACKED_INDICES.length}`;
    if (measurePhase === 'position' || measurePhase === 'side-position') {
      $('btnBeginMeasure').disabled = true;
    }
  }
}

// â”€â”€ Camera â”€â”€
async function startCamera() {
  if (stream) stream.getTracks().forEach(t => t.stop());
  try {
    stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode, width: { ideal: 1280 }, height: { ideal: 720 } },
      audio: false,
    });
    video.srcObject = stream;
    const isMirror = facingMode === 'user';
    video.classList.toggle('mirror', isMirror);
    overlay.classList.toggle('mirror', isMirror);

    await new Promise(r => video.addEventListener('loadeddata', r, { once: true }));
    overlay.width = video.videoWidth;
    overlay.height = video.videoHeight;
  } catch (e) {
    alert('ã‚«ãƒ¡ãƒ©ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã›ã‚“: ' + e.message);
  }
}

// â”€â”€ MediaPipe Init â”€â”€
async function initMediaPipe() {
  try {
    $('loadingText').textContent = 'WASM ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã‚’èª­ã¿è¾¼ã¿ä¸­...';
    const vision = await FilesetResolver.forVisionTasks(VISION_CDN);
    $('loadingText').textContent = 'GPU ã§å§¿å‹¢æ¨å®šãƒ¢ãƒ‡ãƒ«ã‚’èª­ã¿è¾¼ã¿ä¸­...';
    poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
      baseOptions: { modelAssetPath: MODEL_FULL, delegate: 'GPU' },
      runningMode: 'VIDEO',
      numPoses: 1,
      minPoseDetectionConfidence: 0.15,
      minPosePresenceConfidence: 0.15,
      minTrackingConfidence: 0.15,
    });
    delegate = 'GPU';
  } catch (e) {
    console.warn('GPU failed:', e);
    try {
      $('loadingText').textContent = 'CPU ãƒ¢ãƒ¼ãƒ‰ã§å†è©¦è¡Œä¸­...';
      const vision = await FilesetResolver.forVisionTasks(VISION_CDN);
      poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
        baseOptions: { modelAssetPath: MODEL_LITE, delegate: 'CPU' },
        runningMode: 'VIDEO',
        numPoses: 1,
        minPoseDetectionConfidence: 0.5,
        minPosePresenceConfidence: 0.5,
        minTrackingConfidence: 0.5,
      });
      delegate = 'CPU';
    } catch (e2) {
      $('loadingText').textContent = 'ã‚¨ãƒ©ãƒ¼: ' + e2.message;
      return;
    }
  }
  navigateTo('mode');
}

// â”€â”€ Navigation â”€â”€
function navigateTo(screen) {
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
  const map = { loading: 'screenLoading', mode: 'screenMode', settings: 'screenSettings', measure: 'screenMeasure', export: 'screenExport' };
  $(map[screen]).classList.add('active');
}

// â”€â”€ Wheel Picker â”€â”€
function initWheelPicker() {
  const container = $('heightPicker');
  const list = $('heightPickerList');
  const minVal = 100, maxVal = 200;
  const itemH = 40;
  const padding = 80;

  list.innerHTML = '';
  for (let v = minVal; v <= maxVal; v++) {
    const div = document.createElement('div');
    div.className = 'wheel-picker-item';
    div.textContent = v;
    div.dataset.value = v;
    list.appendChild(div);
  }

  const totalItems = maxVal - minVal + 1;
  let currentIndex = selectedHeight - minVal;
  let offset = -(currentIndex * itemH) + padding;

  function updatePosition(animated) {
    list.style.transition = animated ? 'transform 0.3s cubic-bezier(0.2, 0.8, 0.3, 1)' : 'none';
    list.style.transform = `translateY(${offset}px)`;
    const items = list.children;
    for (let i = 0; i < items.length; i++) {
      items[i].classList.toggle('selected', i === currentIndex);
    }
    selectedHeight = currentIndex + minVal;
  }

  function snapToNearest() {
    currentIndex = Math.round((-offset + padding) / itemH);
    currentIndex = Math.max(0, Math.min(totalItems - 1, currentIndex));
    offset = -(currentIndex * itemH) + padding;
    updatePosition(true);
  }

  let startY = 0, startOffset = 0, lastY = 0, lastTime = 0, velocity = 0;
  let isDragging = false;

  function onStart(e) {
    isDragging = true;
    const y = e.touches ? e.touches[0].clientY : e.clientY;
    startY = y; lastY = y; lastTime = Date.now(); startOffset = offset; velocity = 0;
    list.style.transition = 'none';
  }

  function onMove(e) {
    if (!isDragging) return;
    e.preventDefault();
    const y = e.touches ? e.touches[0].clientY : e.clientY;
    const now = Date.now();
    const dt = now - lastTime;
    if (dt > 0) velocity = (y - lastY) / dt;
    lastY = y; lastTime = now;
    offset = startOffset + (y - startY);
    const maxOffset = padding;
    const minOffset = -((totalItems - 1) * itemH) + padding;
    if (offset > maxOffset) offset = maxOffset + (offset - maxOffset) * 0.3;
    if (offset < minOffset) offset = minOffset + (offset - minOffset) * 0.3;
    list.style.transform = `translateY(${offset}px)`;
  }

  function onEnd() {
    if (!isDragging) return;
    isDragging = false;
    const inertia = velocity * 150;
    offset += inertia;
    const maxOffset = padding;
    const minOffset = -((totalItems - 1) * itemH) + padding;
    offset = Math.max(minOffset, Math.min(maxOffset, offset));
    snapToNearest();
  }

  container.addEventListener('touchstart', onStart, { passive: true });
  container.addEventListener('touchmove', onMove, { passive: false });
  container.addEventListener('touchend', onEnd);
  container.addEventListener('mousedown', onStart);
  window.addEventListener('mousemove', onMove);
  window.addEventListener('mouseup', onEnd);
  updatePosition(false);
}

// â”€â”€ Measurement Flow â”€â”€
function startCountdown(onComplete) {
  let count = COUNTDOWN_DURATION;
  const numEl = $('countdownNumber');
  const labelEl = $('countdownLabel');

  numEl.classList.add('visible');
  labelEl.textContent = 'æº–å‚™ã—ã¦ãã ã•ã„';
  numEl.textContent = count;
  numEl.style.fontSize = '100px';

  countdownTimer = setInterval(() => {
    count--;
    if (count <= 0) {
      clearInterval(countdownTimer);
      numEl.classList.remove('visible');
      labelEl.textContent = '';
      onComplete();
    } else {
      numEl.textContent = count;
    }
  }, 1000);
}

function startMeasuring(isSide) {
  measurePhase = isSide ? 'side-measuring' : 'measuring';
  isSideMeasuring = isSide;
  $('statusBadge').textContent = 'è¨ˆæ¸¬ä¸­';
  $('statusBadge').className = 'status-badge recording';
  $('measureControls').style.display = 'none';
  $('measureProgress').style.display = 'block';

  const numEl = $('countdownNumber');
  const labelEl = $('countdownLabel');
  numEl.style.fontSize = '120px';
  numEl.classList.add('visible');
  labelEl.textContent = 'è¨ˆæ¸¬ä¸­';

  let remaining = MEASURE_DURATION;
  numEl.textContent = remaining;
  measureStartTime = performance.now();

  countdownTimer = setInterval(() => {
    remaining--;
    const elapsed = MEASURE_DURATION - remaining;
    $('measureProgressBar').style.width = `${(elapsed / MEASURE_DURATION) * 100}%`;

    if (remaining <= 0) {
      clearInterval(countdownTimer);
      numEl.classList.remove('visible');
      labelEl.textContent = '';
      $('measureProgress').style.display = 'none';

      if (appMode === 'thorough' && !isSide) {
        measurePhase = 'side-switch';
        showSideSwitch();
      } else {
        measurePhase = 'done';
        isSideMeasuring = false;
        finishMeasurement();
      }
    } else {
      numEl.textContent = remaining;
    }
  }, 1000);
}

function showSideSwitch() {
  const overlay = $('sideSwitchOverlay');
  const sideText = selectedSide === 'left' ? 'å·¦å´é¢' : 'å³å´é¢';
  $('sideSwitchText').textContent = `ã‚«ãƒ¡ãƒ©ã‚’ç§»å‹•ã—ã¦ã€${sideText}ãŒæ˜ ã‚‹ã‚ˆã†ã«ã—ã¦ãã ã•ã„`;
  overlay.classList.add('visible');
}

function startSidePosition() {
  $('sideSwitchOverlay').classList.remove('visible');
  measurePhase = 'side-position';
  emaLandmarks = null;
  $('statusBadge').textContent = 'å´é¢ æº–å‚™ä¸­';
  $('statusBadge').className = 'status-badge loading';
  $('measureControls').style.display = 'flex';
  $('btnBeginMeasure').disabled = true;
  $('btnBeginMeasure').textContent = 'å´é¢è¨ˆæ¸¬é–‹å§‹';
}

function beginMeasure() {
  if (measurePhase === 'position') {
    measurePhase = 'countdown';
    $('measureControls').style.display = 'none';
    startCountdown(() => startMeasuring(false));
  } else if (measurePhase === 'side-position') {
    measurePhase = 'side-countdown';
    $('measureControls').style.display = 'none';
    startCountdown(() => startMeasuring(true));
  }
}

function finishMeasurement() {
  isDetecting = false;
  if (stream) stream.getTracks().forEach(t => t.stop());
  stream = null;
  showExportScreen();
}

// â”€â”€ Export Screen â”€â”€
function showExportScreen() {
  const totalFrames = frontFrames.length + sideFrames.length;
  const metricCount = appMode === 'thorough'
    ? FRONT_METRIC_KEYS.length + SIDE_METRIC_KEYS.length
    : FRONT_METRIC_KEYS.length;

  let avgFps = 0;
  if (frontFrames.length >= 2) {
    const duration = (frontFrames[frontFrames.length - 1].timestamp - frontFrames[0].timestamp) / 1000;
    avgFps = duration > 0 ? Math.round(frontFrames.length / duration) : 0;
  }

  $('exportSummaryText').textContent =
    (appMode === 'simple' ? 'ç°¡æ˜“ãƒ¢ãƒ¼ãƒ‰' : 'ã—ã£ã‹ã‚Šãƒ¢ãƒ¼ãƒ‰') + `ãƒ»${MEASURE_DURATION}ç§’é–“`;
  $('statFrames').textContent = totalFrames;
  $('statMetrics').textContent = metricCount;
  $('statFps').textContent = avgFps;

  navigateTo('export');
}

// â”€â”€ TXT Generation â”€â”€
function generateTxt(detailed) {
  const now = new Date();
  const dateStr = now.toISOString().slice(0, 19);

  let txt = '';

  txt += '[header]\n';
  txt += `app: å§¿å‹¢ã‚¹ã‚­ãƒ£ãƒ³\n`;
  txt += `version: 1.0\n`;
  txt += `date: ${dateStr}\n`;
  txt += `mode: ${appMode}\n`;
  txt += `duration_sec: ${MEASURE_DURATION}\n`;
  txt += `fps: ${currentFps}\n`;
  txt += `total_frames: ${frontFrames.length + sideFrames.length}\n`;
  txt += `height_cm: ${selectedHeight}\n`;
  if (appMode === 'thorough') {
    txt += `side_view: ${selectedSide}\n`;
    txt += `side_frames: ${sideFrames.length}\n`;
  }
  txt += '\n';

  txt += '[front_metrics_summary]\n';
  for (const key of FRONT_METRIC_KEYS) {
    const values = frontFrames.map(f => f.metrics[key]).filter(v => v !== null && v !== undefined);
    if (values.length === 0) continue;
    const s = calcStats(values);
    txt += `${key}: avg=${s.avg} sd=${s.sd} min=${s.min} max=${s.max}\n`;
  }
  txt += '\n';

  if (appMode === 'thorough' && sideFrames.length > 0) {
    txt += '[side_metrics_summary]\n';
    for (const key of SIDE_METRIC_KEYS) {
      const values = sideFrames.map(f => f.metrics[key]).filter(v => v !== null && v !== undefined);
      if (values.length === 0) continue;
      const s = calcStats(values);
      txt += `${key}: avg=${s.avg} sd=${s.sd} min=${s.min} max=${s.max}\n`;
    }
    txt += '\n';
  }

  txt += '[landmark_confidence]\n';
  for (const name of TRACKED_NAMES) {
    const data = confidenceAccum[name];
    if (!data || data.vis.length === 0) continue;
    const avgVis = (data.vis.reduce((a, b) => a + b, 0) / data.vis.length).toFixed(2);
    txt += `${name}: visibility=${avgVis}\n`;
  }
  txt += '\n';

  txt += ANALYSIS_HINTS;
  txt += '\n';
  txt += REFERENCES;
  txt += '\n';

  if (detailed) {
    txt += generateFrameDataSection('front', frontFrames, FRONT_METRIC_KEYS);
    if (appMode === 'thorough' && sideFrames.length > 0) {
      txt += generateFrameDataSection('side', sideFrames, SIDE_METRIC_KEYS);
    }
  }

  return txt;
}

function generateFrameDataSection(prefix, frames, metricKeys) {
  if (frames.length === 0) return '';
  const coordCols = TRACKED_NAMES.flatMap(n => [`${n}_x`, `${n}_y`, `${n}_z`]);
  const header = ['frame', 'timestamp', ...coordCols, ...metricKeys].join(',');
  let section = `[${prefix}_frame_data]\n`;
  section += header + '\n';

  for (let i = 0; i < frames.length; i++) {
    const f = frames[i];
    const row = [i, ((f.timestamp - frames[0].timestamp) / 1000).toFixed(3)];
    for (const lm of f.landmarks) {
      row.push(lm.x, lm.y, lm.z);
    }
    for (const key of metricKeys) {
      const v = f.metrics[key];
      row.push(v !== null && v !== undefined ? (+v).toFixed(1) : '');
    }
    section += row.join(',') + '\n';
  }

  section += '\n';
  return section;
}

function downloadTxt(content, filename) {
  const blob = new Blob([content], { type: 'text/plain; charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
}

function getExportFilename(detailed) {
  const now = new Date();
  const d = now.toISOString().slice(0, 10);
  const t = now.toTimeString().slice(0, 5).replace(':', '');
  return `posture_scan_${d}_${t}${detailed ? '_detail' : ''}.txt`;
}

// â”€â”€ Event Handlers â”€â”€
function setupEventHandlers() {
  $('btnSimple').addEventListener('click', () => {
    appMode = 'simple';
    $('sideSelectionCard').style.display = 'none';
    navigateTo('settings');
  });
  $('btnThorough').addEventListener('click', () => {
    appMode = 'thorough';
    $('sideSelectionCard').style.display = 'block';
    navigateTo('settings');
  });

  $('btnSideLeft').addEventListener('click', () => {
    selectedSide = 'left';
    $('sideSegment').classList.remove('right');
    $('btnSideLeft').classList.add('active');
    $('btnSideRight').classList.remove('active');
    $('sideDescText').textContent = 'å·¦å´é¢ã‹ã‚‰æ’®å½±ã—ã¾ã™ã€‚å£ã‚„ãƒ‰ã‚¢ã®å‰ãªã©ã€èƒŒæ™¯ãŒã‚·ãƒ³ãƒ—ãƒ«ãªå ´æ‰€ãŒãŠã™ã™ã‚ã§ã™';
  });
  $('btnSideRight').addEventListener('click', () => {
    selectedSide = 'right';
    $('sideSegment').classList.add('right');
    $('btnSideRight').classList.add('active');
    $('btnSideLeft').classList.remove('active');
    $('sideDescText').textContent = 'å³å´é¢ã‹ã‚‰æ’®å½±ã—ã¾ã™ã€‚å£ã‚„ãƒ‰ã‚¢ã®å‰ãªã©ã€èƒŒæ™¯ãŒã‚·ãƒ³ãƒ—ãƒ«ãªå ´æ‰€ãŒãŠã™ã™ã‚ã§ã™';
  });

  $('btnStartMeasure').addEventListener('click', async () => {
    navigateTo('measure');
    frontFrames = [];
    sideFrames = [];
    confidenceAccum = {};
    emaLandmarks = null;
    measurePhase = 'position';
    isSideMeasuring = false;

    $('statusBadge').textContent = 'æº–å‚™ä¸­';
    $('statusBadge').className = 'status-badge loading';
    $('measureControls').style.display = 'flex';
    $('btnBeginMeasure').disabled = true;
    $('btnBeginMeasure').textContent = 'è¨ˆæ¸¬é–‹å§‹';

    await startCamera();
    isDetecting = true;
    lastVideoTime = -1;
    frameCount = 0;
    fpsTime = performance.now();
    detectLoop();

    setTimeout(() => {
      $('statusBadge').textContent = 'ãƒã‚¸ã‚·ãƒ§ãƒ³ç¢ºèª';
      $('statusBadge').className = 'status-badge ready';
    }, 500);
  });

  $('btnBeginMeasure').addEventListener('click', beginMeasure);
  $('btnSideReady').addEventListener('click', startSidePosition);

  $('btnCameraToggle').addEventListener('click', async () => {
    facingMode = facingMode === 'user' ? 'environment' : 'user';
    await startCamera();
  });

  $('btnExportSimple').addEventListener('click', () => {
    const txt = generateTxt(false);
    downloadTxt(txt, getExportFilename(false));
  });
  $('btnExportDetail').addEventListener('click', () => {
    const txt = generateTxt(true);
    downloadTxt(txt, getExportFilename(true));
  });

  $('btnRetry').addEventListener('click', () => {
    frontFrames = [];
    sideFrames = [];
    confidenceAccum = {};
    emaLandmarks = null;
    measurePhase = 'idle';
    isSideMeasuring = false;
    navigateTo('mode');
  });
}

// â”€â”€ Analysis Hints â”€â”€
const ANALYSIS_HINTS = `[analysis_hints]
- SDå€¤ãŒä½ã™ãã‚‹æŒ‡æ¨™ã¯ã€Œç¡¬ã„ãƒ»ç·Šå¼µã—ã¦ã„ã‚‹ã€ã‚µã‚¤ãƒ³ã®å¯èƒ½æ€§ãŒã‚ã‚‹
- å€‹äººå·®ãŒå¤§ãã„ãŸã‚ã€çµ¶å¯¾å€¤ã‚ˆã‚Šå€‹äººã®ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³ã‹ã‚‰ã®ã‚ºãƒ¬ã§åˆ¤æ–­ã™ã¹ã
- å‰åŠã¨å¾ŒåŠã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿ã‚’æ¯”è¼ƒã™ã‚‹ã¨ã€15ç§’é–“ã®å§¿å‹¢ãƒ‰ãƒªãƒ•ãƒˆï¼ˆç–²åŠ´ãƒ»ç·Šå¼µï¼‰ã‚’æ¤œå‡ºã§ãã‚‹
- è‚©ã®yåº§æ¨™ã®å‘¨æœŸçš„æŒ¯å‹•ã‹ã‚‰å‘¼å¸ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆæ·±ã•ãƒ»é »åº¦ï¼‰ã‚’æ¨å®šã§ãã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹
- CVAï¼ˆé ­è“‹æ¤éª¨è§’ï¼‰: >53åº¦ãŒæ­£å¸¸ã€45ã€œ53åº¦ãŒè»½ã€œä¸­ç­‰åº¦ã€<45åº¦ãŒé‡åº¦ã®å‰æ–¹é ­ä½
- FSAï¼ˆå‰æ–¹è‚©è§’åº¦ï¼‰: 54åº¦ä»¥ä¸‹ã§å·»ãè‚©ï¼ˆRounded Shouldersï¼‰ã¨åˆ¤å®š
- èƒ¸æ¤å¾Œå¼¯: æ­£å¸¸ç¯„å›²ã¯20ã€œ40åº¦ï¼ˆCobbè§’ï¼‰ã€40åº¦è¶…ã§éå¾Œå¼¯
- éª¨ç›¤å‰å‚¾: æ­£å¸¸ãªå‰å‚¾ã¯7ã€œ13åº¦ã€‚éåº¦ãªå‰å‚¾ã¯è…°ç—›ãƒªã‚¹ã‚¯
- è†å¤–åè§’: æ­£å¸¸ã¯5ã€œ7åº¦ã€‚éåº¦ãªå¤–åï¼ˆXè„šï¼‰ã¯è†é–¢ç¯€ã¸ã®è² æ‹…å¢—
- ãƒ—ãƒ©ãƒ ãƒ©ã‚¤ãƒ³: ç†æƒ³çš„ã«ã¯è€³â†’è‚©â†’è‚¡é–¢ç¯€â†’è†â†’ãã‚‹ã¶ã—ãŒå‚ç›´ä¸€ç·šä¸Š
- æŒ‡æ¨™é–“ã®ç›¸é–¢ï¼ˆä¾‹: é ­éƒ¨å‰æ–¹å¤‰ä½â†”å·»ãè‚©ï¼‰ã¯ä»£å„Ÿé‹å‹•ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ç¤ºå”†ã™ã‚‹
- è†ã‚¢ãƒ©ã‚¤ãƒ¡ãƒ³ãƒˆã¨éª¨ç›¤å‚¾æ–œã®ç›¸é–¢ãŒé«˜ã„å ´åˆã€ä¸‹è‚¢ã®æ§‹é€ çš„å•é¡Œã‚’ç¤ºå”†
`;

// â”€â”€ References â”€â”€
const REFERENCES = `[references]
- Physiopedia: Craniovertebral Angle â€” FHPã®æ¨™æº–çš„æŒ‡æ¨™ã€‚CVA >53Â°æ­£å¸¸, <45Â°é‡åº¦
- IJATT 2021: "Which Specific Angle Measurement Criteria Should be Used" â€” FSA â‰¤54Â°ã§å·»ãè‚©åˆ¤å®š
- JOSPT 1996: "Clinical Measurement of Head and Shoulder Posture Variables" â€” é ­éƒ¨ãƒ»è‚©éƒ¨è¨ˆæ¸¬ã®ä¿¡é ¼æ€§
- PMC 2020: "Normal Range of Thoracic Kyphosis and Lumbar Lordosis" â€” èƒ¸æ¤å¾Œå¼¯æ­£å¸¸å€¤20-40Â°
- PubMed 2011: "Assessment of pelvic tilt in normal asymptomatic population" â€” éª¨ç›¤å‰å‚¾å¹³å‡13Â°
- PMC 2024: "Two Methods of Forward Head Posture Assessment" â€” CVAé–¾å€¤53Â°ã¨50Â°
- PMC 2012: "Analysis of the Anterior Trunk Symmetry Index (ATSI)" â€” ä½“å¹¹å¯¾ç§°æ€§è©•ä¾¡
- Physiopedia: Cobb Angle â€” å´å¼¯ç—‡ã‚¹ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°åŸºæº–10Â°
- Physiopedia: Q Angle â€” è†ã‚¢ãƒ©ã‚¤ãƒ¡ãƒ³ãƒˆç”·æ€§12Â°/å¥³æ€§17Â°
- PMC 2021: "Clinical Measures of Pelvic Tilt" â€” éª¨ç›¤å‚¾æ–œã®è‡¨åºŠçš„è¨ˆæ¸¬æ³•
- ACSM: "Assessing Static Posture Part I" â€” ãƒ—ãƒ©ãƒ ãƒ©ã‚¤ãƒ³è©•ä¾¡æ³•
- Kendallæ³•: ãƒ—ãƒ©ãƒ ãƒ©ã‚¤ãƒ³ã®ç†æƒ³çš„é€šéç‚¹ï¼ˆå¤–è€³é“â†’è‚©å³°â†’å¤§è»¢å­â†’è…“éª¨é ­â†’å¤–æœå‰æ–¹ï¼‰
- PMC 2024: "Comprehensive analysis of ML pose estimation models" â€” MediaPipeç²¾åº¦ï¼ˆä¸Šè‚¢r=0.91ï¼‰
- PMC 2021: "A mobile application tool for standing posture analysis" â€” ãƒ¢ãƒã‚¤ãƒ«å§¿å‹¢åˆ†æã®å¦¥å½“æ€§
- Hignett & McAtamney 2000: "REBA: Rapid Entire Body Assessment" â€” å…¨èº«å§¿å‹¢è©•ä¾¡æ³•
- McAtamney & Corlett 1993: "RULA: survey method for upper limb disorders" â€” ä¸Šè‚¢éšœå®³èª¿æŸ»æ³•
- NYPR 1958: New York Posture Rating Chart â€” 13ã‚»ã‚°ãƒ¡ãƒ³ãƒˆ3æ®µéšè©•ä¾¡
`;

// â”€â”€ Init â”€â”€
setupEventHandlers();
initWheelPicker();
initMediaPipe();
</script>
</body>
</html>
